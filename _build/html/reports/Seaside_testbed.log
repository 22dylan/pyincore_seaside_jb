Traceback (most recent call last):
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/jupyter_cache/executors/utils.py", line 56, in single_nb_execution
    record_timing=False,
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/client.py", line 1117, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/util.py", line 78, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/util.py", line 57, in just_run
    return loop.run_until_complete(coro)
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/asyncio/base_events.py", line 587, in run_until_complete
    return future.result()
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/client.py", line 559, in async_execute
    cell, index, execution_count=self.code_cells_executed + 1
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/client.py", line 862, in async_execute_cell
    self._check_raise_for_error(cell, exec_reply)
  File "/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/nbclient/client.py", line 765, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
mc_bldg_eq_dmg_result_list = []        # place holder to saving mc earthquake building damage result iteration
mc_bldg_tsu_dmg_result_list = []       # place holder to saving mc tsunami building damage result iteration
mc_bldg_cumul_dmg_result_list = []     # place holder to saving mc cumulative building damage result iteration

mc = MonteCarloFailureProbability(client)     # initializing pyincore
for index, rt_val in enumerate(rt):
    print('Recurrence Interval: {}' .format(rt_val))
    # --- earthquake MC failure ---
    result_name = 'mc_buildings_eq_' + str(rt_val) + 'yr'
    
    # running mc sampling in pyincore
    damage_dataset = bldg_eq_dmg_result_list[index]
    mc.set_input_dataset("damage", damage_dataset)           # importing csv to pyincore
    mc.set_parameter("result_name", result_name)             # defining result_name
    mc.set_parameter("num_cpu", 1)                           # number of CPUs for parallel processing
    mc.set_parameter("num_samples", 1000)                     # number of MC samples
    mc.set_parameter("damage_interval_keys", ["DS_0", "DS_1", "DS_2", "DS_3"])  # damage interval keys
    mc.set_parameter("failure_state_keys", ["DS_1", "DS_2", "DS_3"])   # damage keys classified as "failure"
    mc.run_analysis()                                        # running MC analysis
    mc_bldg_eq_dmg_result_list.append(mc.get_output_dataset('failure_probability'))
    
    # --- tsunami MC failure ---
    # repeating above analysis, but for tsunami
    result_name = 'mc_buildings_tsu_' + str(rt_val) + 'yr'
    # running mc sampling in pyincore
    damage_dataset = bldg_tsu_dmg_result_list[index]
    mc.set_input_dataset("damage", damage_dataset)
    mc.set_parameter("result_name", result_name)
    mc.set_parameter("num_cpu", 1)
    mc.set_parameter("num_samples", 1000)
    mc.set_parameter("damage_interval_keys", ["DS_0", "DS_1", "DS_2", "DS_3"])
    mc.set_parameter("failure_state_keys", ["DS_1", "DS_2", "DS_3"])
    mc.run_analysis()
    mc_bldg_tsu_dmg_result_list.append(mc.get_output_dataset('failure_probability'))
    
    # --- multi-hazard MC failure ---
    # repeating above analysis, but for multi-hazard results
    result_name = 'mc_buildings_cumulative_' + str(rt_val) + 'yr'

    # running mc sampling in pyincore
    damage_dataset = cumulative_bldg_dmg_result_list[index]
    mc.set_input_dataset("damage", damage_dataset)
    mc.set_parameter("result_name", result_name)
    mc.set_parameter("num_cpu", 1)
    mc.set_parameter("num_samples", 1000)
    mc.set_parameter("damage_interval_keys", ["DS_0", "DS_1", "DS_2", "DS_3"])
    mc.set_parameter("failure_state_keys", ["DS_1", "DS_2", "DS_3"])
    mc.run_analysis()
    mc_bldg_cumul_dmg_result_list.append(mc.get_output_dataset('failure_probability'))
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mKeyboardInterrupt[0m                         Traceback (most recent call last)
[0;32m<ipython-input-7-451e7a0f8025>[0m in [0;36m<module>[0;34m[0m
[1;32m     31[0m     [0mmc[0m[0;34m.[0m[0mset_parameter[0m[0;34m([0m[0;34m"damage_interval_keys"[0m[0;34m,[0m [0;34m[[0m[0;34m"DS_0"[0m[0;34m,[0m [0;34m"DS_1"[0m[0;34m,[0m [0;34m"DS_2"[0m[0;34m,[0m [0;34m"DS_3"[0m[0;34m][0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m     32[0m     [0mmc[0m[0;34m.[0m[0mset_parameter[0m[0;34m([0m[0;34m"failure_state_keys"[0m[0;34m,[0m [0;34m[[0m[0;34m"DS_1"[0m[0;34m,[0m [0;34m"DS_2"[0m[0;34m,[0m [0;34m"DS_3"[0m[0;34m][0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 33[0;31m     [0mmc[0m[0;34m.[0m[0mrun_analysis[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     34[0m     [0mmc_bldg_tsu_dmg_result_list[0m[0;34m.[0m[0mappend[0m[0;34m([0m[0mmc[0m[0;34m.[0m[0mget_output_dataset[0m[0;34m([0m[0;34m'failure_probability'[0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m     35[0m [0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/pyincore/baseanalysis.py[0m in [0;36mrun_analysis[0;34m(self)[0m
[1;32m    262[0m                 [0;32mreturn[0m [0mresult[0m[0;34m[0m[0;34m[0m[0m
[1;32m    263[0m [0;34m[0m[0m
[0;32m--> 264[0;31m         [0;32mreturn[0m [0mself[0m[0;34m.[0m[0mrun[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    265[0m [0;34m[0m[0m
[1;32m    266[0m     [0;32mdef[0m [0mrun[0m[0;34m([0m[0mself[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/pyincore/analyses/montecarlofailureprobability/montecarlofailureprobability.py[0m in [0;36mrun[0;34m(self)[0m
[1;32m    163[0m         fs_results, fp_results, samples_results = self.monte_carlo_failure_probability_concurrent_future(
[1;32m    164[0m             [0mself[0m[0;34m.[0m[0mmonte_carlo_failure_probability_bulk_input[0m[0;34m,[0m [0mnum_workers[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 165[0;31m             inventory_args, seed_list)
[0m[1;32m    166[0m         self.set_result_csv_data("sample_failure_state",
[1;32m    167[0m                                  fs_results, name=self.get_parameter("result_name") + "_failure_state")

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/site-packages/pyincore/analyses/montecarlofailureprobability/montecarlofailureprobability.py[0m in [0;36mmonte_carlo_failure_probability_concurrent_future[0;34m(self, function_name, parallelism, *args)[0m
[1;32m    191[0m         with concurrent.futures.ProcessPoolExecutor(
[1;32m    192[0m                 max_workers=parallelism) as executor:
[0;32m--> 193[0;31m             [0;32mfor[0m [0mfs_ret[0m[0;34m,[0m [0mfp_ret[0m[0;34m,[0m [0msamples_ret[0m [0;32min[0m [0mexecutor[0m[0;34m.[0m[0mmap[0m[0;34m([0m[0mfunction_name[0m[0;34m,[0m [0;34m*[0m[0margs[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    194[0m                 [0mfs_output[0m[0;34m.[0m[0mextend[0m[0;34m([0m[0mfs_ret[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    195[0m                 [0mfp_output[0m[0;34m.[0m[0mextend[0m[0;34m([0m[0mfp_ret[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/concurrent/futures/process.py[0m in [0;36m_chain_from_iterable_of_lists[0;34m(iterable)[0m
[1;32m    481[0m     [0mcareful[0m [0;32mnot[0m [0mto[0m [0mkeep[0m [0mreferences[0m [0mto[0m [0myielded[0m [0mobjects[0m[0;34m.[0m[0;34m[0m[0;34m[0m[0m
[1;32m    482[0m     """
[0;32m--> 483[0;31m     [0;32mfor[0m [0melement[0m [0;32min[0m [0miterable[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    484[0m         [0melement[0m[0;34m.[0m[0mreverse[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    485[0m         [0;32mwhile[0m [0melement[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/concurrent/futures/_base.py[0m in [0;36mresult_iterator[0;34m()[0m
[1;32m    596[0m                     [0;31m# Careful not to keep a reference to the popped future[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[1;32m    597[0m                     [0;32mif[0m [0mtimeout[0m [0;32mis[0m [0;32mNone[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 598[0;31m                         [0;32myield[0m [0mfs[0m[0;34m.[0m[0mpop[0m[0;34m([0m[0;34m)[0m[0;34m.[0m[0mresult[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    599[0m                     [0;32melse[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[1;32m    600[0m                         [0;32myield[0m [0mfs[0m[0;34m.[0m[0mpop[0m[0;34m([0m[0;34m)[0m[0;34m.[0m[0mresult[0m[0;34m([0m[0mend_time[0m [0;34m-[0m [0mtime[0m[0;34m.[0m[0mmonotonic[0m[0;34m([0m[0;34m)[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/concurrent/futures/_base.py[0m in [0;36mresult[0;34m(self, timeout)[0m
[1;32m    428[0m                 [0;32mreturn[0m [0mself[0m[0;34m.[0m[0m__get_result[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    429[0m [0;34m[0m[0m
[0;32m--> 430[0;31m             [0mself[0m[0;34m.[0m[0m_condition[0m[0;34m.[0m[0mwait[0m[0;34m([0m[0mtimeout[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    431[0m [0;34m[0m[0m
[1;32m    432[0m             [0;32mif[0m [0mself[0m[0;34m.[0m[0m_state[0m [0;32min[0m [0;34m[[0m[0mCANCELLED[0m[0;34m,[0m [0mCANCELLED_AND_NOTIFIED[0m[0;34m][0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m

[0;32m/usr/local/Caskroom/miniconda/base/envs/pyincore/lib/python3.7/threading.py[0m in [0;36mwait[0;34m(self, timeout)[0m
[1;32m    294[0m         [0;32mtry[0m[0;34m:[0m    [0;31m# restore state no matter what (e.g., KeyboardInterrupt)[0m[0;34m[0m[0;34m[0m[0m
[1;32m    295[0m             [0;32mif[0m [0mtimeout[0m [0;32mis[0m [0;32mNone[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 296[0;31m                 [0mwaiter[0m[0;34m.[0m[0macquire[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    297[0m                 [0mgotit[0m [0;34m=[0m [0;32mTrue[0m[0;34m[0m[0;34m[0m[0m
[1;32m    298[0m             [0;32melse[0m[0;34m:[0m[0;34m[0m[0;34m[0m[0m

[0;31mKeyboardInterrupt[0m: 
KeyboardInterrupt: 

